apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: ${ARGOCD_ENV_utils_argocd_helm_app_name}
  namespace: ${ARGOCD_ENV_utils_app_namespace}
  annotations:
    argocd.argoproj.io/sync-wave: ${ARGOCD_ENV_utils_sync_wave}

  # Add this finalizer ONLY if you want these to cascade delete (A cascade delete, deletes both the app and its resources, rather than only the app.)
  # finalizers:
  #   - resources-finalizer.argocd.argoproj.io

spec:
  project: default
  syncPolicy:
    syncOptions:
      - CreateNamespace=true
      - PrunePropagationPolicy=foreground

    automated:
      prune: false
      selfHeal: false

  destination:
    server: "https://kubernetes.default.svc"
    namespace: ${ARGOCD_ENV_utils_argocd_namespace}

  sources:
    - chart: argo-cd
      repoURL: https://argoproj.github.io/argo-helm
      targetRevision: ${ARGOCD_ENV_utils_argocd_helm_helm_version}

      helm:
        releaseName: ${ARGOCD_ENV_utils_argocd_helm_app_name}
        valuesObject:
          fullnameOverride: ${ARGOCD_ENV_utils_argocd_helm_app_name}
          crds:
            install: true
          global:
            domain: argo.${ARGOCD_ENV_utils_argocd_helm_public_ingress_access_domain}
            logging:
              format: json

          applicationSet:
            enabled: false
          notifications:
            enabled: false
          configs:
            secret:
              createSecret: false
            cm:
              url: http://argo.${ARGOCD_ENV_utils_argocd_helm_public_ingress_access_domain}
              exec.enabled: "true"
              kustomize.buildOptions: "--load-restrictor LoadRestrictionsNone"
              # DO NOT USE in production, this is only used to improve reconciliation in testing env.
              timeout.reconciliation: "10s"
              application.resourceTrackingMethod: annotation
              resource.exclusions: |
                - apiGroups:
                  - "*"
                  kinds:
                  - ProviderConfigUsage
              resource.customizations: |
                argoproj.io/Application:
                  health.lua: |
                    hs = {}
                    hs.status = "Progressing"
                    hs.message = ""
                    if obj.status ~= nil then
                      if obj.status.health ~= nil then
                        hs.status = obj.status.health.status
                        if obj.status.health.message ~= nil then
                          hs.message = obj.status.health.message
                        end
                      end
                    end
                    return hs
                cert-manager.io/Certificate:
                  health.lua: |
                    hs = {}
                    if obj.status ~= nil then
                      if obj.status.conditions ~= nil then
                        for i, condition in ipairs(obj.status.conditions) do
                          if condition.type == "Ready" and condition.status == "False" then
                            hs.status = "Degraded"
                            hs.message = condition.message
                            return hs
                          end
                          if condition.type == "Ready" and condition.status == "True" then
                            hs.status = "Healthy"
                            hs.message = condition.message
                            return hs
                          end
                        end
                      end
                    end

                    hs.status = "Progressing"
                    hs.message = "Waiting for certificate"
                    return hs
                redhatcop.redhat.io/VaultSecret:
                  health.lua: |
                    hs = {}
                    if obj.status ~= nil then
                      if obj.status.conditions ~= nil then
                        for i, condition in ipairs(obj.status.conditions) do
                          if condition.type == "ReconcileSuccessful" and condition.status == "False" then
                            hs.status = "Degraded"
                            hs.message = condition.message
                            return hs
                          end
                          if condition.type == "ReconcileSuccessful" and condition.status == "True" then
                            hs.status = "Healthy"
                            hs.message = condition.message
                            return hs
                          end
                        end
                      end
                    end

                    hs.status = "Progressing"
                    hs.message = "Waiting for VaultSecret"
                    return hs

                ceph.rook.io/CephBlockPool:
                  health.lua: |
                    hs = {}
                    if obj.status ~= nil then
                      if obj.status.phase == "Ready" then
                        hs.status = "Healthy"
                        hs.message = "CephBlockPool Ready"
                        return hs
                      end
                    end
                    hs.status = "Progressing"
                    hs.message = "Waiting for CephBlockPool"
                    return hs

                "*.upbound.io/*":
                  health.lua: |
                    health_status = {
                      status = "Progressing",
                      message = "Provisioning ..."
                    }

                    local function contains (table, val)
                      for i, v in ipairs(table) do
                        if v == val then
                          return true
                        end
                      end
                      return false
                    end

                    local has_no_status = {
                      "ProviderConfig",
                      "ProviderConfigUsage"
                    }

                    if obj.status == nil or next(obj.status) == nil and contains(has_no_status, obj.kind) then
                      health_status.status = "Healthy"
                      health_status.message = "Resource is up-to-date."
                      return health_status
                    end

                    if obj.status == nil or next(obj.status) == nil or obj.status.conditions == nil then
                      if obj.kind == "ProviderConfig" and obj.status.users ~= nil then
                        health_status.status = "Healthy"
                        health_status.message = "Resource is in use."
                        return health_status
                      end
                      return health_status
                    end

                    for i, condition in ipairs(obj.status.conditions) do
                      if condition.type == "LastAsyncOperation" then
                        if condition.status == "False" then
                          health_status.status = "Degraded"
                          health_status.message = condition.message
                          return health_status
                        end
                      end

                      if condition.type == "Synced" then
                        if condition.status == "False" then
                          health_status.status = "Degraded"
                          health_status.message = condition.message
                          return health_status
                        end
                      end

                      if condition.type == "Ready" then
                        if condition.status == "True" then
                          health_status.status = "Healthy"
                          health_status.message = "Resource is up-to-date."
                          return health_status
                        end
                      end
                    end

                    return health_status

                "*.crossplane.io/*":
                  health.lua: |
                    health_status = {
                      status = "Progressing",
                      message = "Provisioning ..."
                    }

                    local function contains (table, val)
                      for i, v in ipairs(table) do
                        if v == val then
                          return true
                        end
                      end
                      return false
                    end

                    local has_no_status = {
                      "Composition",
                      "CompositionRevision",
                      "DeploymentRuntimeConfig",
                      "ControllerConfig",
                      "ProviderConfig",
                      "ProviderConfigUsage"
                    }
                    if obj.status == nil or next(obj.status) == nil and contains(has_no_status, obj.kind) then
                        health_status.status = "Healthy"
                        health_status.message = "Resource is up-to-date."
                      return health_status
                    end

                    if obj.status == nil or next(obj.status) == nil or obj.status.conditions == nil then
                      if obj.kind == "ProviderConfig" and obj.status.users ~= nil then
                        health_status.status = "Healthy"
                        health_status.message = "Resource is in use."
                        return health_status
                      end
                      return health_status
                    end

                    for i, condition in ipairs(obj.status.conditions) do
                      if condition.type == "LastAsyncOperation" then
                        if condition.status == "False" then
                          health_status.status = "Degraded"
                          health_status.message = condition.message
                          return health_status
                        end
                      end

                      if condition.type == "Synced" then
                        if condition.status == "False" then
                          health_status.status = "Degraded"
                          health_status.message = condition.message
                          return health_status
                        end
                      end

                      if contains({"Ready", "Healthy", "Offered", "Established"}, condition.type) then
                        if condition.status == "True" then
                          health_status.status = "Healthy"
                          health_status.message = "Resource is up-to-date."
                          return health_status
                        end
                      end
                    end

                    return health_status
              # dex.config: |
              #   connectors:
              #     - id: google
              #       name: Google
              #       type: oidc
              #       config:
              #         issuer: https://accounts.google.com
              #         clientID: $dex.client.id # read from argo-secrets
              #         clientSecret: $dex.client.secret # read from argo-secrets
              # extension.config: |-
              #   extensions:
              #     - name: metrics
              #       backend:
              #         services:
              #         - url: http://argocd-metrics-server.argocd.svc.cluster.local:9003

            params:
              server.insecure: true
              # Mandatory for extensions to work
              server.enable.proxy.extension: "true"
            rbac:
              policy.default: role:readonly
              policy.csv: |-
                p, role:readonly, extensions, invoke, metrics, allow
                p, role:admin, extensions, invoke, metrics, allow
            cmp:
              create: true
              plugins:
                envsubstappofapp:
                  init:
                    command: ["sh", "-c"]
                    args:
                      [
                        "kustomize build . --load-restrictor LoadRestrictionsNone -o raw-kustomization.yaml",
                      ]
                  generate:
                    command: ["sh", "-c"]
                    args:
                      [
                        "envsubst < raw-kustomization.yaml > processed-kustomization.yaml && cp processed-kustomization.yaml /dev/stdout",
                      ]
                  discover:
                    fileName: "kustomization.*"
                envsubst:
                  discover:
                    fileName: "kustomization.*"
                  generate:
                    command: ["sh", "-c"]
                    args:
                      [
                        "for f in *.yaml ; do cat $f | envsubst > $f.sub && mv $f.sub $f ; done && kustomize build . --enable-helm --helm-kube-version 1.29-0 --load-restrictor LoadRestrictionsNone > /dev/stdout",
                      ]

          ## Controller ##
          controller:
            # resources:
            #   limits:
            #     cpu: 1
            #     memory: 1024Mi
            #   requests:
            #     cpu: 500m
            #     memory: 1024Mi
            metrics:
              enabled: false
              serviceMonitor:
                enabled: false
                namespace: argocd
                additionalLabels:
                  prometheus.io/scrap-with: kube-prometheus-stack

          ## DEX ##
          dex:
            enabled: false
            metrics:
              enabled: true
              serviceMonitor:
                enabled: false # enable for production
                namespace: argocd
                additionalLabels:
                  prometheus.io/scrap-with: kube-prometheus-stack

          ## RepoServer ##
          repoServer:
            # resources:
            #   limits:
            #     cpu: 500m
            #     memory: 1.5Gi
            #   requests:
            #     cpu: 250m
            #     memory: 512Mi

            volumes:
              - name: custom-tools
                emptyDir: {}
              - name: cmp-plugin
                configMap:
                  name: argocd-cmp-cm

            initContainers:
              - name: download-tools
                image: golang:1.22.4-alpine3.20
                command: [sh, -c]
                args:
                  - apk add git && go install github.com/drone/envsubst/cmd/envsubst@v1.0.3 && mv $GOPATH/bin/envsubst /custom-tools/
                volumeMounts:
                  - mountPath: /custom-tools
                    name: custom-tools

            extraContainers:
              - name: debug-tools
                image: quay.io/argoproj/argocd
                command: [sh, -c]
                args:
                  - while true; do echo "running"; sleep 300; done
                volumeMounts:
                  - mountPath: /var/run/argocd
                    name: var-files
                  - mountPath: /home/argocd/cmp-server/plugins
                    name: plugins
                  - mountPath: /tmp
                    name: tmp

                  # Important: Mount tools into $PATH
                  - name: custom-tools
                    subPath: envsubst
                    mountPath: /usr/local/bin/envsubst
                  - name: custom-tools
                    subPath: yq
                    mountPath: /usr/local/bin/yq

              - name: envsubstappofapp
                command: [/var/run/argocd/argocd-cmp-server]
                image: quay.io/argoproj/argocd
                args: [--loglevel, debug]
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 999
                volumeMounts:
                  - mountPath: /var/run/argocd
                    name: var-files
                  - mountPath: /home/argocd/cmp-server/plugins
                    name: plugins
                  - mountPath: /tmp
                    name: tmp

                  # Register plugins into sidecar
                  - mountPath: /home/argocd/cmp-server/config/plugin.yaml
                    subPath: envsubstappofapp.yaml
                    name: cmp-plugin

                  # Important: Mount tools into $PATH
                  - name: custom-tools
                    subPath: envsubst
                    mountPath: /usr/local/bin/envsubst
                  - name: custom-tools
                    subPath: yq
                    mountPath: /usr/local/bin/yq

              - name: envsubst
                command: [/var/run/argocd/argocd-cmp-server]
                image: quay.io/argoproj/argocd
                args: [--loglevel, debug]
                securityContext:
                  runAsNonRoot: true
                  runAsUser: 999
                volumeMounts:
                  - mountPath: /var/run/argocd
                    name: var-files
                  - mountPath: /home/argocd/cmp-server/plugins
                    name: plugins
                  - mountPath: /tmp
                    name: tmp

                  # Register plugins into sidecar
                  - mountPath: /home/argocd/cmp-server/config/plugin.yaml
                    subPath: envsubst.yaml
                    name: cmp-plugin

                  # Important: Mount tools into $PATH
                  - name: custom-tools
                    subPath: envsubst
                    mountPath: /usr/local/bin/envsubst
                  - name: custom-tools
                    subPath: yq
                    mountPath: /usr/local/bin/yq

            metrics:
              enabled: false
              serviceMonitor:
                enabled: false
                namespace: argocd
                additionalLabels:
                  prometheus.io/scrap-with: kube-prometheus-stack

          ## Server ##
          server:
            # resources:
            #   limits:
            #     cpu: 400m
            #     memory: 512Mi
            #   requests:
            #     cpu: 400m
            #     memory: 512Mi
            metrics:
              enabled: false
              serviceMonitor:
                enabled: false
                additionalLabels:
                  prometheus.io/scrap-with: kube-prometheus-stack
                namespace: argocd
            ingress:
              enabled: false

            extensions:
              enabled: true
              extensionList:
                # - name: metrics
                #   env:
                #     - name: EXTENSION_URL
                #       value: https://github.com/argoproj-labs/argocd-extension-metrics/releases/download/v1.0.3/extension.tar.gz
                #     - name: EXTENSION_CHECKSUM_URL
                #       value: https://github.com/argoproj-labs/argocd-extension-metrics/releases/download/v1.0.3/extension_checksums.txt
                - name: rollout
                  env:
                    - name: EXTENSION_URL
                      value: https://github.com/argoproj-labs/rollout-extension/releases/download/v0.3.5/extension.tar

              resources:
                {}
                # limits:
                #   cpu: 50m
                #   memory: 128Mi
                # requests:
                #   cpu: 10m
                #   memory: 64Mi

          ## Redis ##
          redis:
            resources:
              limits:
                cpu: 120m
                memory: 256Mi
              requests:
                cpu: 120m
                memory: 256Mi
            metrics:
              enabled: false
              serviceMonitor:
                enabled: false
                additionalLabels:
                  prometheus.io/scrap-with: kube-prometheus-stack
                namespace: argocd
