apiVersion: batch/v1
kind: Job
metadata:
  name: rook-ceph-external-job
  namespace: rook-ceph-external
spec:
  template:
    spec:
      restartPolicy: Never
      serviceAccountName: ceph-job-sa
      containers:
        - name: kubectl-consumer
          volumeMounts:
            - mountPath: /data/ceph_env
              name: ceph-env
              readOnly: true
          image: bitnami/kubectl:latest
          command:
            - /bin/bash
            - -c
            - |
              echo "Additional env vars"
              KUBECTL="kubectl"
              NAMESPACE=$${NAMESPACE:="rook-ceph-external"}
              ROOK_EXTERNAL_CLUSTER_NAME=$NAMESPACE
              MON_SECRET_NAME=rook-ceph-mon
              MON_SECRET_FSID_KEYNAME=fsid
              MON_SECRET_CLUSTER_NAME_KEYNAME=cluster-name
              MON_SECRET_ADMIN_KEYRING_KEYNAME=admin-secret
              MON_SECRET_MON_KEYRING_KEYNAME=mon-secret
              MON_SECRET_CEPH_USERNAME_KEYNAME=ceph-username
              MON_SECRET_CEPH_SECRET_KEYNAME=ceph-secret
              MON_ENDPOINT_CONFIGMAP_NAME=rook-ceph-mon-endpoints
              ROOK_EXTERNAL_MONITOR_SECRET=mon-secret
              EXTERNAL_COMMAND_CONFIGMAP_NAME=external-cluster-user-command
              RGW_ADMIN_OPS_USER_SECRET_NAME=rgw-admin-ops-user
              ROOK_EXTERNAL_MAX_MON_ID=2
              ROOK_EXTERNAL_MAPPING={}
              ROOK_RBD_FEATURES="layering"
              RBD_STORAGE_CLASS_NAME=block
              CEPHFS_STORAGE_CLASS_NAME=filesystem
              OBJECT_STORAGE_CLASS_NAME=bucket
              CLUSTER_ID_RBD=$NAMESPACE
              CLUSTER_ID_CEPHFS=$NAMESPACE
              OPERATOR_NAMESPACE=rook-ceph
              CSI_DRIVER_NAME_PREFIX=$OPERATOR_NAMESPACE
              RBD_PROVISIONER=$CSI_DRIVER_NAME_PREFIX".rbd.csi.ceph.com"
              CEPHFS_PROVISIONER=$CSI_DRIVER_NAME_PREFIX".cephfs.csi.ceph.com"
              OBJECT_PROVISIONER=$NAMESPACE".ceph.rook.io/bucket"
              OBJECT_STORE_NAME=external-store
              : "$${ROOK_EXTERNAL_ADMIN_SECRET:=admin-secret}"

              # Ensure file is not empty before source
              if [ -s /data/ceph_env/config ]; then
                source /data/ceph_env/config
              else 
                echo "Error: /data/ceph_env/config is empty!"
                exit 1
              fi
              ## Functions
              function checkEnvVars() {
                if [ -z "$NAMESPACE" ]; then
                  echo "Please populate the environment variable NAMESPACE"
                  exit 1
                fi
                if [ -z "$ROOK_EXTERNAL_FSID" ]; then
                  echo "Please populate the environment variable ROOK_EXTERNAL_FSID"
                  exit 1
                fi
                if [ -z "$ROOK_EXTERNAL_CEPH_MON_DATA" ]; then
                  echo "Please populate the environment variable ROOK_EXTERNAL_CEPH_MON_DATA"
                  exit 1
                fi
                if [ -z "$ROOK_EXTERNAL_CEPH_MON_DATA" ]; then
                  echo "Please populate the environment variable ROOK_EXTERNAL_CEPH_MON_DATA"
                  exit 1
                fi
                if [[ "$ROOK_EXTERNAL_ADMIN_SECRET" == "admin-secret" ]]; then
                  if [ -z "$ROOK_EXTERNAL_USER_SECRET" ]; then
                    echo "Please populate the environment variable ROOK_EXTERNAL_USER_SECRET"
                    exit 1
                  fi
                  if [ -z "$ROOK_EXTERNAL_USERNAME" ]; then
                    echo "Please populate the environment variable ROOK_EXTERNAL_USERNAME"
                    exit 1
                  fi
                fi
                if [[ "$ROOK_EXTERNAL_ADMIN_SECRET" != "admin-secret" ]] && [ -n "$ROOK_EXTERNAL_USER_SECRET" ]; then
                  echo "Providing both ROOK_EXTERNAL_ADMIN_SECRET and ROOK_EXTERNAL_USER_SECRET is not supported, choose one only."
                  exit 1
                fi
                }
              function createClusterNamespace() {
                if ! $KUBECTL get namespace "$NAMESPACE" &>/dev/null; then
                  $KUBECTL \
                    create \
                    namespace \
                    "$NAMESPACE"
                else
                  echo "cluster namespace $NAMESPACE already exists"
                fi
              }
              function importSecret() {
                if ! $KUBECTL -n "$NAMESPACE" get secret "$MON_SECRET_NAME" &>/dev/null; then
                  $KUBECTL -n "$NAMESPACE" \
                    create \
                    secret \
                    generic \
                    --type="kubernetes.io/rook" \
                    "$MON_SECRET_NAME" \
                    --from-literal="$MON_SECRET_CLUSTER_NAME_KEYNAME"="$ROOK_EXTERNAL_CLUSTER_NAME" \
                    --from-literal="$MON_SECRET_FSID_KEYNAME"="$ROOK_EXTERNAL_FSID" \
                    --from-literal="$MON_SECRET_ADMIN_KEYRING_KEYNAME"="$ROOK_EXTERNAL_ADMIN_SECRET" \
                    --from-literal="$MON_SECRET_MON_KEYRING_KEYNAME"="$ROOK_EXTERNAL_MONITOR_SECRET" \
                    --from-literal="$MON_SECRET_CEPH_USERNAME_KEYNAME"="$ROOK_EXTERNAL_USERNAME" \
                    --from-literal="$MON_SECRET_CEPH_SECRET_KEYNAME"="$ROOK_EXTERNAL_USER_SECRET"
                else
                  echo "secret $MON_SECRET_NAME already exists"
                fi
              }
              function importConfigMap() {
                if ! $KUBECTL -n "$NAMESPACE" get configmap "$MON_ENDPOINT_CONFIGMAP_NAME" &>/dev/null; then
                  $KUBECTL -n "$NAMESPACE" \
                    create \
                    configmap \
                    "$MON_ENDPOINT_CONFIGMAP_NAME" \
                    --from-literal=data="$ROOK_EXTERNAL_CEPH_MON_DATA" \
                    --from-literal=mapping="$ROOK_EXTERNAL_MAPPING" \
                    --from-literal=maxMonId="$ROOK_EXTERNAL_MAX_MON_ID"
                else
                  echo "configmap $MON_ENDPOINT_CONFIGMAP_NAME already exists"
                fi
              }
              function createInputCommadConfigMap() {
                if ! $KUBECTL -n "$NAMESPACE" get configmap "$EXTERNAL_COMMAND_CONFIGMAP_NAME" &>/dev/null; then
                  $KUBECTL -n "$NAMESPACE" \
                    create \
                    configmap \
                    "$EXTERNAL_COMMAND_CONFIGMAP_NAME" \
                    --from-literal=args="$ARGS"
                else
                  echo "configmap $EXTERNAL_COMMAND_CONFIGMAP_NAME already exists, updating it"
                  $KUBECTL -n "$NAMESPACE" \
                    patch \
                    configmap \
                    "$EXTERNAL_COMMAND_CONFIGMAP_NAME" \
                    -p "$(jq -n --arg args "$ARGS" '{"data": {"args": $args}}')"
                fi
              }
              function importCsiRBDNodeSecret() {
                if ! $KUBECTL -n "$NAMESPACE" get secret "rook-$CSI_RBD_NODE_SECRET_NAME" &>/dev/null; then
                  $KUBECTL -n "$NAMESPACE" \
                    create \
                    secret \
                    generic \
                    --type="kubernetes.io/rook" \
                    "rook-""$CSI_RBD_NODE_SECRET_NAME" \
                    --from-literal=userID="$CSI_RBD_NODE_SECRET_NAME" \
                    --from-literal=userKey="$CSI_RBD_NODE_SECRET"
                else
                  echo "secret rook-$CSI_RBD_NODE_SECRET_NAME already exists"
                fi
              }
              function importCsiRBDProvisionerSecret() {
                if ! $KUBECTL -n "$NAMESPACE" get secret "rook-$CSI_RBD_PROVISIONER_SECRET_NAME" &>/dev/null; then
                  $KUBECTL -n "$NAMESPACE" \
                    create \
                    secret \
                    generic \
                    --type="kubernetes.io/rook" \
                    "rook-""$CSI_RBD_PROVISIONER_SECRET_NAME" \
                    --from-literal=userID="$CSI_RBD_PROVISIONER_SECRET_NAME" \
                    --from-literal=userKey="$CSI_RBD_PROVISIONER_SECRET"
                else
                  echo "secret $CSI_RBD_PROVISIONER_SECRET_NAME already exists"
                fi
              }
              function importCsiCephFSNodeSecret() {
                if ! $KUBECTL -n "$NAMESPACE" get secret "rook-$CSI_CEPHFS_NODE_SECRET_NAME" &>/dev/null; then
                  $KUBECTL -n "$NAMESPACE" \
                    create \
                    secret \
                    generic \
                    --type="kubernetes.io/rook" \
                    "rook-""$CSI_CEPHFS_NODE_SECRET_NAME" \
                    --from-literal=adminID="$CSI_CEPHFS_NODE_SECRET_NAME" \
                    --from-literal=adminKey="$CSI_CEPHFS_NODE_SECRET"
                else
                  echo "secret $CSI_CEPHFS_NODE_SECRET_NAME already exists"
                fi
              }
              function importCsiCephFSProvisionerSecret() {
                if ! $KUBECTL -n "$NAMESPACE" get secret "rook-$CSI_CEPHFS_PROVISIONER_SECRET_NAME" &>/dev/null; then
                  $KUBECTL -n "$NAMESPACE" \
                    create \
                    secret \
                    generic \
                    --type="kubernetes.io/rook" \
                    "rook-""$CSI_CEPHFS_PROVISIONER_SECRET_NAME" \
                    --from-literal=adminID="$CSI_CEPHFS_PROVISIONER_SECRET_NAME" \
                    --from-literal=adminKey="$CSI_CEPHFS_PROVISIONER_SECRET"
                else
                  echo "secret $CSI_CEPHFS_PROVISIONER_SECRET_NAME already exists"
                fi
              }
              function importRGWAdminOpsUser() {
                if ! $KUBECTL -n "$NAMESPACE" get secret "$RGW_ADMIN_OPS_USER_SECRET_NAME" &>/dev/null; then
                  $KUBECTL -n "$NAMESPACE" \
                    create \
                    secret \
                    generic \
                    --type="kubernetes.io/rook" \
                    "$RGW_ADMIN_OPS_USER_SECRET_NAME" \
                    --from-literal=accessKey="$RGW_ADMIN_OPS_USER_ACCESS_KEY" \
                    --from-literal=secretKey="$RGW_ADMIN_OPS_USER_SECRET_KEY"
                else
                  echo "secret $RGW_ADMIN_OPS_USER_SECRET_NAME already exists"
                fi
              }
              function createRBDStorageClass() {
                if ! $KUBECTL -n "$NAMESPACE" get storageclass $RBD_STORAGE_CLASS_NAME &>/dev/null; then
                  cat <<eof | $KUBECTL create -f -
              apiVersion: storage.k8s.io/v1
              kind: StorageClass
              metadata:
                name: $RBD_STORAGE_CLASS_NAME
                annotations:
                  storageclass.kubernetes.io/is-default-class: "true"
              provisioner: $RBD_PROVISIONER
              parameters:
                clusterID: $CLUSTER_ID_RBD
                pool: $RBD_POOL_NAME
                imageFormat: "2"
                imageFeatures: $ROOK_RBD_FEATURES
                csi.storage.k8s.io/provisioner-secret-name: "rook-$CSI_RBD_PROVISIONER_SECRET_NAME"
                csi.storage.k8s.io/provisioner-secret-namespace: $NAMESPACE
                csi.storage.k8s.io/controller-expand-secret-name:  "rook-$CSI_RBD_PROVISIONER_SECRET_NAME"
                csi.storage.k8s.io/controller-expand-secret-namespace: $NAMESPACE
                csi.storage.k8s.io/node-stage-secret-name: "rook-$CSI_RBD_NODE_SECRET_NAME"
                csi.storage.k8s.io/node-stage-secret-namespace: $NAMESPACE
                csi.storage.k8s.io/fstype: ext4
              allowVolumeExpansion: true
              reclaimPolicy: Delete
              eof
                else
                  echo "storageclass $RBD_STORAGE_CLASS_NAME already exists"
                fi
              }
              function createCephFSStorageClass() {
                if ! $KUBECTL -n "$NAMESPACE" get storageclass $CEPHFS_STORAGE_CLASS_NAME &>/dev/null; then
                  cat <<eof | $KUBECTL create -f -
              apiVersion: storage.k8s.io/v1
              kind: StorageClass
              metadata:
                name: $CEPHFS_STORAGE_CLASS_NAME
              provisioner: $CEPHFS_PROVISIONER
              parameters:
                clusterID: $CLUSTER_ID_CEPHFS
                fsName: $CEPHFS_FS_NAME
                pool: $CEPHFS_POOL_NAME
                csi.storage.k8s.io/provisioner-secret-name: "rook-$CSI_CEPHFS_PROVISIONER_SECRET_NAME"
                csi.storage.k8s.io/provisioner-secret-namespace: $NAMESPACE
                csi.storage.k8s.io/controller-expand-secret-name: "rook-$CSI_CEPHFS_PROVISIONER_SECRET_NAME"
                csi.storage.k8s.io/controller-expand-secret-namespace: $NAMESPACE
                csi.storage.k8s.io/node-stage-secret-name: "rook-$CSI_CEPHFS_NODE_SECRET_NAME"
                csi.storage.k8s.io/node-stage-secret-namespace: $NAMESPACE
              allowVolumeExpansion: true
              reclaimPolicy: Delete
              eof
                else
                  echo "storageclass $CEPHFS_STORAGE_CLASS_NAME already exists"
                fi
              }
              function createObjectStorageClass() {
                if ! $KUBECTL -n "$NAMESPACE" get storageclass $OBJECT_STORAGE_CLASS_NAME &>/dev/null; then
                  cat <<eof | $KUBECTL create -f -
              apiVersion: storage.k8s.io/v1
              kind: StorageClass
              metadata:
                name: $OBJECT_STORAGE_CLASS_NAME
              provisioner: $OBJECT_PROVISIONER
              reclaimPolicy: Delete
              volumeBindingMode: "Immediate"
              parameters:
                objectStoreName: $OBJECT_STORE_NAME
                objectStoreNamespace: $NAMESPACE
                region: "us-east-1"
              eof
                else
                  echo "storageclass $OBJECT_STORAGE_CLASS_NAME already exists"
                fi
              }
              function createCephObjectStore() {
                if ! $KUBECTL -n "$NAMESPACE" get cephobjectstore $OBJECT_STORE_NAME &>/dev/null; then
                  cat <<eof | $KUBECTL create -f -
              apiVersion: ceph.rook.io/v1
              kind: CephObjectStore
              metadata:
                name: $OBJECT_STORE_NAME
                namespace: $NAMESPACE
              spec:
                gateway:
                  port: $RGW_EXTERNAL_PORT
                  instances: 1
                  externalRgwEndpoints:
                    - ip: $RGW_EXTERNAL_IP
              eof
                fi
              }
              # MAIN
              checkEnvVars
              createClusterNamespace
              importSecret
              importConfigMap
              createInputCommadConfigMap
              if [ -n "$CSI_RBD_NODE_SECRET_NAME" ] && [ -n "$CSI_RBD_NODE_SECRET" ]; then
                importCsiRBDNodeSecret
              fi
              if [ -n "$CSI_RBD_PROVISIONER_SECRET_NAME" ] && [ -n "$CSI_RBD_PROVISIONER_SECRET" ]; then
                importCsiRBDProvisionerSecret
              fi
              if [ -n "$RGW_ADMIN_OPS_USER_ACCESS_KEY" ] && [ -n "$RGW_ADMIN_OPS_USER_SECRET_KEY" ]; then
                importRGWAdminOpsUser
              fi
              if [ -n "$CSI_CEPHFS_NODE_SECRET_NAME" ] && [ -n "$CSI_CEPHFS_NODE_SECRET" ]; then
                importCsiCephFSNodeSecret
              fi
              if [ -n "$CSI_CEPHFS_PROVISIONER_SECRET_NAME" ] && [ -n "$CSI_CEPHFS_PROVISIONER_SECRET" ]; then
                importCsiCephFSProvisionerSecret
              fi
              if [ -n "$RBD_POOL_NAME" ]; then
                createRBDStorageClass
              fi
              if [ -n "$CEPHFS_FS_NAME" ] && [ -n "$CEPHFS_POOL_NAME" ]; then
                createCephFSStorageClass
              fi
              if [ -n "$RGW_EXTERNAL_IP" ]; then
                createCephObjectStore
                createObjectStorageClass
              fi
      volumes:
        - name: ceph-env
          secret:
            secretName: ceph-external-cluster-secret